Based on the provided hardware and environment information, here is the adjusted and optimized environment setup plan.

The plan has been tailored for your `linux/amd64` environment (Debian/Ubuntu base), focuses on the contributor workflow within the existing `/home/cc/EnvGym/data/rayon-rs_rayon` directory, and includes optimizations for multi-core builds and Docker/BuildKit caching.

=== ENVIRONMENT SETUP PLAN (ADJUSTED) ===

1.  **DOWNLOADS NEEDED:**
    *   **Rust Toolchain (via rustup)**: This includes the Rust compiler (`rustc`), package manager (`cargo`), and standard library. The `rayon-core` crate, which manages the thread pool, has a specific minimum version requirement.
        *   Version Requirement: `rustc 1.80.0` or newer. CI jobs specifically use `1.80.0` for checks and formatting.
        *   Toolchains: `stable`, `beta`, `nightly` (install via `rustup toolchain install <name>`). The `nightly` toolchain is required for running benchmarks.
        *   Components: `rustfmt` is required for code formatting checks (install via `rustup component add rustfmt`).
    *   **Git**: Required for interacting with the project repository.
    *   **(Recommended) GitHub CLI (`gh`)**: Optional but recommended for contributors to streamline interaction with the GitHub repository, including checking out pull requests from Dependabot.
    *   **(Recommended) IDE with Rust Support**: Optional but recommended for a better development experience. Examples include Visual Studio Code with the `rust-analyzer` extension or a JetBrains IDE like CLion.
    *   **System-level Build and Graphics Dependencies**: Required to compile crates with build scripts (`build.rs`), run graphical demos, and build for different CPU architectures. For your `linux/amd64` Debian/Ubuntu-based environment, these are essential.
        *   **On Debian/Ubuntu**: `sudo apt install build-essential pkg-config libgtk-3-dev libx11-dev libxcb-render0-dev libxcb-shape0-dev libxcb-xfixes0-dev libssl-dev gcc-multilib` (note: `gcc-multilib` is for i686 cross-compilation).
    *   **(Optional) Rust Cross-compilation Targets**: Required for building for architectures other than your host machine.
        *   32-bit Linux: `rustup target add i686-unknown-linux-gnu`
        *   WebAssembly (Standalone): `rustup target add wasm32-unknown-unknown`
        *   WebAssembly (WASI): `rustup target add wasm32-wasip1`
    *   **(Optional) wasm-bindgen and related tools**: Required for creating and running multi-threaded WebAssembly modules. For multi-threading, tools compatible with `wasm-bindgen-rayon` are necessary.
    *   **(Optional) Wasmtime**: A runtime for WebAssembly & WASI, required for running the WASI test suite.
        *   Version Requirement: `v35.0.0` or compatible.
        *   Installation Command: `curl https://wasmtime.dev/install.sh -sSf | bash -s -- --version v35.0.0`

2.  **KEY FILES & DIRECTORIES TO UNDERSTAND (within `/home/cc/EnvGym/data/rayon-rs_rayon`):**
    *   **`.github/`**: Contains configuration for GitHub Actions CI (`workflows/`) and Dependabot (`dependabot.yml`). Contributors should consult these files to understand the full scope of automated checks.
    *   **`ci/`**: Contains scripts and configuration for Continuous Integration, including `highlander.sh` (ensures a single `rayon-core` version) and `compat-Cargo.lock` (pins dependencies for compatibility checks).
    *   **`rayon-core/`**: The core crate containing the thread pool scheduler.
        *   `rayon-core/build.rs`: A build script that requires a C compiler toolchain and ensures only one version of `rayon-core` is linked.
        *   `rayon-core/README.md`: Explains that users should depend on the main `rayon` crate, not `rayon-core` directly.
        *   `rayon-core/src/sleep/README.md`: A highly technical document for advanced contributors detailing the internal concurrency protocol for the thread pool. Essential reading for modifying the core scheduler.
    *   **`rayon/`**: The main `rayon` crate that users depend on.
        *   `src/iter/plumbing/README.md`: A highly technical document for advanced contributors detailing the internal "plumbing" of parallel iterators (Producers/Consumers). Essential reading for modifying iterator combinators.
    *   **`rayon-demo/`**: A crate containing demos and benchmarks.
        *   `data/`: Contains data files (e.g., for the TSP benchmark) needed to run the benchmarks and demos.
        *   `examples/`: Contains interactive, often graphical, tests that are not run by CI but can be run manually (e.g., `mandelbrot.rs`).
    *   **`.gitignore`**: Instructs Git to ignore build artifacts (`target/`) and other non-source files. The root `Cargo.lock` is intentionally ignored to allow `cargo` to resolve the latest compatible dependencies, while CI uses specific lockfiles for reproducibility.

3.  **NECESSARY TEST CASES IN THE CODEBASE:**
    *   **Code Formatting Check (Contributor)**: Run `cargo fmt --all --check` to ensure code adheres to project style guidelines. This is a required check in pull requests.
    *   **CI Compatibility Check (Contributor)**: Replicate the PR `check` job by copying the checked-in lock file (`cp ci/compat-Cargo.lock ./Cargo.lock`) and running `cargo check --verbose --locked`. This validates your changes against the exact dependencies used in CI.
    *   **Full Repository Test Suite Execution (Advanced/Contributor)**: Run the core tests from the official repository: `cargo test --verbose --package rayon`, `cargo test --verbose --package rayon-core`, and the CI script `./ci/highlander.sh`. These tests are critical for validating the complex concurrency logic of the thread pool and parallel iterators.
    *   **Graphical Demo Execution Test (Optional)**: Run the `nbody` simulation demo (`cargo run --release -p rayon-demo -- nbody visualize`) to verify system-level graphics dependencies are correctly installed.
    *   **Interactive Example Execution Test (Optional)**: Run an example from the `rayon-demo/examples/` directory (e.g., `cargo run --release --example mandelbrot`) to verify that interactive, non-CI tests also function correctly.
    *   **CI Environment Replication Note**: The CI environment sets a 16MB stack size (`RUST_MIN_STACK=16777216`). For deep recursion tests, especially in debug mode, you may need to set this environment variable locally (`export RUST_MIN_STACK=16777216`) to avoid stack overflows.
    *   **32-bit (i686) Target Compilation Test (Optional/Contributor)**: Compile and test for the `i686` target using `cargo test --target i686-unknown-linux-gnu`. This verifies your cross-compilation setup.
    *   **WebAssembly (WASI) Execution Test (Optional)**: For the `wasm32-wasip1` target, run `cargo test --target wasm32-wasip1`. This requires `wasmtime` to be installed and configured as the Cargo runner.
    *   **Benchmark Execution (Advanced/Contributor)**: Run the project's benchmarks using `cargo +nightly bench --all`. This requires the `nightly` Rust toolchain.
    *   **Dependency Update Validation Test (Advanced/Contributor)**: Check out a Dependabot pull request and run the full test suite (`cargo test --workspace`) to verify that an updated dependency does not introduce regressions.

4.  **COMPLETE TODO LIST:**
    *   **Step 1: Install Toolchains and System Dependencies**
        *   Action: Install the Rust toolchain via `rustup.rs`: `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh`.
        *   Action: Install the `rustfmt` component: `rustup component add rustfmt`.
        *   Action: (For contributors) Install other toolchains: `rustup toolchain install beta` and `rustup toolchain install nightly`.
        *   Action: Install Git and (optionally) the GitHub CLI (`gh`).
        *   Action: Install platform-specific dependencies for your Debian/Ubuntu-based environment: `sudo apt-get update && sudo apt-get install -y build-essential pkg-config libgtk-3-dev libx11-dev libxcb-render0-dev libxcb-shape0-dev libxcb-xfixes0-dev libssl-dev gcc-multilib`.
        *   Verification: Run `rustc --version`, `cargo --version`, `git --version`, and `cargo fmt --version`. Ensure `rustc` is `1.80.0` or higher.

    *   **Step 2: Build and Test the Cloned Rayon Repository**
        *   **Prerequisite**: You are already in the working directory: `/home/cc/EnvGym/data/rayon-rs_rayon`.
        *   **Optimization Note**: Your environment has a high CPU core count. You can significantly speed up builds and tests by setting the number of parallel jobs. For example: `export CARGO_BUILD_JOBS=$(nproc)`.
        *   **Prerequisite**: To fully replicate the CI environment, you may need to set the stack size: `export RUST_MIN_STACK=16777216`.
        *   **(Advanced Contributor) Note**: To understand the core concurrency models before making changes, it is highly recommended to read the technical documentation in `rayon-core/src/sleep/README.md` and `rayon/src/iter/plumbing/README.md`.
        *   **Sub-step 2a: Run Code Formatting Check**
            *   Action: `cargo fmt --all --check`.
            *   Verification: The command exits successfully, indicating no formatting changes are needed.
        *   **Sub-step 2b: Run CI Compatibility Checks (Advanced)**
            *   Action: `cp ci/compat-Cargo.lock ./Cargo.lock`
            *   Action: `cargo check --verbose --locked`.
            *   Verification: The command completes successfully, confirming your changes are compatible with CI-pinned dependencies.
        *   **Sub-step 2c: Run the Full Test Suite (Advanced)**
            *   Action: Run the core tests: `cargo test --verbose --package rayon`, `cargo test --verbose --package rayon-core`, and `./ci/highlander.sh`.
            *   Verification: All tests pass. The successful execution of `highlander.sh` confirms that the dependency tree correctly resolves to a single version of `rayon-core`.
        *   **Sub-step 2d: Run Graphical and Interactive Demos**
            *   Action: `cargo run --release -p rayon-demo -- nbody visualize`.
            *   Verification: A window opens displaying the N-body simulation.
            *   Action: `cargo run --release -p rayon-demo --example mandelbrot`.
            *   Verification: A window opens displaying the Mandelbrot set fractal.

    *   **Step 3: (Optional) Set up for Cross-Compilation and Benchmarks**
        *   **Sub-step 3a: Run 32-bit (i686) Build (Linux)**
            *   Action: `rustup target add i686-unknown-linux-gnu`.
            *   Action: `cargo test --verbose --target i686-unknown-linux-gnu --package rayon`.
            *   Verification: The tests for the `i686` target compile and pass successfully.
        *   **Sub-step 3b: Run WASI Target Tests**
            *   Action: Install the target: `rustup target add wasm32-wasip1`.
            *   Action: Install wasmtime: `curl https://wasmtime.dev/install.sh -sSf | bash -s -- --version v35.0.0`.
            *   Action: Set the runner environment variable: `export CARGO_TARGET_WASM32_WASIP1_RUNNER="$HOME/.wasmtime/bin/wasmtime"`.
            *   Action: `cargo test --target wasm32-wasip1 --package rayon`.
            *   Verification: Tests run successfully using `wasmtime`.
        *   **Sub-step 3c: Run Benchmarks (Advanced)**
            *   Prerequisite: The `nightly` toolchain must be installed (`rustup toolchain install nightly`).
            *   Action: Run the full benchmark suite: `cargo +nightly bench --all`.
            *   Verification: The benchmarks compile and run to completion.

    *   **Step 4: (Optional) Create and Run a Separate Test Project**
        *   Action: Outside the `rayon-rs_rayon` directory, run `cargo new my_rayon_project` and `cd my_rayon_project`.
        *   Action: Open `Cargo.toml` and add `rayon = "1.11.0"` under `[dependencies]`.
        *   Action: Open `src/main.rs` and add example code (e.g., the `sum_of_squares` function).
        *   Action: Run `cargo run`.
        *   Verification: The build succeeds, and the program prints the expected output (e.g., `Sum of squares: 55`).

    *   **DOCKER/BUILD-KIT OPTIMIZATION NOTES:**
        *   Since you are using Docker with BuildKit, you can dramatically speed up container builds by caching the `rustup` toolchain and `cargo` dependencies. Structure your `Dockerfile` to leverage `RUN --mount=type=cache`:
        ```dockerfile
        # Base image for your linux/amd64 environment
        FROM rust:1.80.0

        # Install system dependencies (as defined in Step 1)
        RUN apt-get update && apt-get install -y \
            pkg-config libgtk-3-dev libx11-dev libxcb-render0-dev \
            libxcb-shape0-dev libxcb-xfixes0-dev libssl-dev gcc-multilib \
            && rm -rf /var/lib/apt/lists/*

        WORKDIR /home/cc/EnvGym/data/rayon-rs_rayon
        COPY . .

        # Use BuildKit cache mounts to persist cargo & rustup data between builds.
        # This prevents re-downloading toolchains and re-compiling all dependencies every time.
        RUN --mount=type=cache,target=/usr/local/rustup/toolchains \
            --mount=type=cache,target=/usr/local/cargo/registry \
            --mount=type=cache,target=./target \
            # Set parallel jobs and run a build/test command
            export CARGO_BUILD_JOBS=$(nproc); \
            cargo test --workspace
        ```